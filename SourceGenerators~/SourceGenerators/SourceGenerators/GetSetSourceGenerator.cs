using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class GetterSetterSourceGenerator : IIncrementalGenerator
{
    struct Metadata
    {
        public string namespaceName;
        public string name;
        public string typeDefinitionName;
        public UsingDirectiveSyntax[] usingDirectives;
        public List<FieldMetadata> fields;
    }

    struct FieldMetadata
    {
        public FieldDeclarationSyntax field;
        public bool hasGetAttribute;
        public bool hasSetAttribute;
    }
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax or StructDeclarationSyntax,
                transform: static (ctx, _) => Transform(ctx))
            .Where(m => m.fields.Count > 0);
        
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static Metadata Transform(GeneratorSyntaxContext context)
    {
        Metadata metadata = default;
        if (context.Node is ClassDeclarationSyntax)
        {
            metadata.typeDefinitionName = "class";
        }
        else if (context.Node is StructDeclarationSyntax)
        {
            metadata.typeDefinitionName = "struct";
        }
        var syntax = (TypeDeclarationSyntax)context.Node;
        metadata.fields = new List<FieldMetadata>();
        metadata.name = syntax.Identifier.ToString();
        metadata.namespaceName = syntax.GetNamespaceName();
        metadata.usingDirectives = syntax.GetUsingDirectives().ToArray();
        var isPublic = SyntaxExtensions.HasModifier(syntax.Modifiers, "public");
        if (!isPublic)
        {
            return metadata;
        }
        foreach (var node in syntax.ChildNodes())
        {
            if (node is not FieldDeclarationSyntax field)
            {
                continue;
            }
            var attributeLists = field.AttributeLists;
            FieldMetadata fieldMetadata = default;
            fieldMetadata.field = field;
            fieldMetadata.hasSetAttribute = SyntaxExtensions.HasAttribute(attributeLists, "SetAttribute", context);
            fieldMetadata.hasGetAttribute = SyntaxExtensions.HasAttribute(attributeLists, "GetAttribute", context);
            if (!fieldMetadata.hasGetAttribute && !fieldMetadata.hasSetAttribute)
            {
                continue;
            }
            metadata.fields.Add(fieldMetadata);
        }
        return metadata;
    }
    
    private void GenerateCode(SourceProductionContext context, Metadata metadata)
    {
        using MemoryStream sourceStream = new();
        using StreamWriter sourceStreamWriter = new(sourceStream, Encoding.UTF8);
        using IndentedTextWriter codeWriter = new(sourceStreamWriter);
        
        codeWriter.WriteLine("//<auto-generated/>");

        foreach (var usingDirective in metadata.usingDirectives)
        {
            codeWriter.WriteLine(usingDirective.ToString());
        }
        if (metadata.usingDirectives.Length > 0)
        {
            codeWriter.WriteLine();
        }
        
        var namespaceName = metadata.namespaceName;
        codeWriter.StartNamespaceScope(namespaceName);

        using (codeWriter.Scope(prefix: $"partial {metadata.typeDefinitionName} {metadata.name}"))
        {
            for (int i = 0, length = metadata.fields.Count; i < length; i++)
            {
                var fieldMetadata = metadata.fields[i];
                var field = fieldMetadata.field;
                var variable = field.Declaration;
                var privateVariableName = variable.Variables[0].Identifier.Text;
                var accessorName = (privateVariableName[0] == '_' ? privateVariableName.Substring(1) : privateVariableName).CapitalizeFirst();
                using (codeWriter.Scope(prefix: $"public {variable.Type.ToString()} {accessorName}"))
                {
                    if (fieldMetadata.hasGetAttribute)
                    {
                        codeWriter.WriteLine($"get => {privateVariableName};");
                    }
                    if (fieldMetadata.hasSetAttribute)
                    {
                        codeWriter.WriteLine($"set => {privateVariableName} = value;");
                    }
                }
                if (i < length - 1)
                {
                    codeWriter.WriteLine();
                }
            }
        }
        
        codeWriter.EndNamespaceScope(namespaceName);
        codeWriter.Flush();
        context.AddSource($"{metadata.name}.g.cs", SourceText.From(sourceStream, Encoding.UTF8, canBeEmbedded: true));
    }
}